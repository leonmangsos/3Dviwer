<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é¹…ä¼´å°è½¦ 3D æ¨¡å‹æŸ¥çœ‹å™¨</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft YaHei', 'Segoe UI', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
            height: 100vh;
            user-select: none;
        }

        .container {
            position: relative;
            width: 100%;
            height: 100vh;
        }

        .header {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        .header h1 {
            font-size: 28px;
            margin-bottom: 5px;
        }

        .header p {
            font-size: 14px;
            opacity: 0.9;
        }

        .controls {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            color: white;
            min-width: 200px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: bold;
        }

        .control-group button {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 8px 15px;
            border-radius: 8px;
            cursor: pointer;
            margin-right: 5px;
            margin-bottom: 5px;
            font-size: 12px;
            transition: all 0.3s ease;
            white-space: nowrap;
        }

        .control-group button:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-1px);
        }

        .control-group button.active {
            background: rgba(76, 175, 80, 0.6);
            border-color: rgba(76, 175, 80, 0.8);
        }

        .control-group input[type="range"] {
            width: 100%;
            margin-top: 5px;
            accent-color: #4CAF50;
        }

        .file-upload {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 200;
            text-align: center;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 40px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 2px dashed rgba(255, 255, 255, 0.3);
            max-width: 500px;
        }

        .file-upload h2 {
            margin-bottom: 20px;
            font-size: 24px;
        }

        .file-upload p {
            margin-bottom: 20px;
            opacity: 0.8;
            line-height: 1.5;
        }

        .file-input-wrapper {
            position: relative;
            display: inline-block;
            margin-bottom: 20px;
        }

        .file-input {
            position: absolute;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        .file-input-button {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            padding: 15px 30px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
        }

        .file-input-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(76, 175, 80, 0.4);
        }

        .demo-button {
            background: linear-gradient(45deg, #2196F3, #1976D2);
            color: white;
            padding: 12px 25px;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
            margin: 0 10px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(33, 150, 243, 0.3);
        }

        .demo-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(33, 150, 243, 0.4);
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 200;
            text-align: center;
            color: white;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top: 3px solid white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 200;
            text-align: center;
            color: white;
            background: rgba(255, 0, 0, 0.2);
            padding: 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            max-width: 400px;
        }

        #canvas-container {
            width: 100%;
            height: 100vh;
        }

        .instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 100;
            color: white;
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            font-size: 12px;
            line-height: 1.5;
            max-width: 300px;
        }

        .instructions h3 {
            margin-bottom: 10px;
            font-size: 14px;
        }

        .instructions ul {
            list-style: none;
        }

        .instructions li {
            margin-bottom: 5px;
        }

        .instructions li:before {
            content: "â€¢ ";
            color: #4CAF50;
            font-weight: bold;
        }

        .drag-drop-area {
            border: 2px dashed rgba(255, 255, 255, 0.5);
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
            transition: all 0.3s ease;
        }

        .drag-drop-area.dragover {
            border-color: #4CAF50;
            background: rgba(76, 175, 80, 0.1);
        }

        .hidden {
            display: none !important;
        }

        .zoom-info {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 100;
            color: white;
            background: rgba(0, 0, 0, 0.3);
            padding: 10px 15px;
            border-radius: 8px;
            backdrop-filter: blur(10px);
            font-size: 12px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .zoom-info.show {
            opacity: 1;
        }

        .axis-controls {
            position: absolute;
            top: 50%;
            left: 20px;
            transform: translateY(-50%);
            z-index: 100;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            color: white;
            min-width: 140px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .axis-controls h3 {
            margin-bottom: 15px;
            font-size: 14px;
            text-align: center;
            color: #4CAF50;
        }

        .axis-group {
            margin-bottom: 15px;
        }

        .axis-group:last-child {
            margin-bottom: 0;
        }

        .axis-label {
            display: block;
            margin-bottom: 8px;
            font-size: 12px;
            font-weight: bold;
            text-align: center;
        }

        .axis-buttons {
            display: flex;
            justify-content: space-between;
            gap: 8px;  /* å¢åŠ æŒ‰é’®é—´è· */
        }

        .axis-btn {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 12px 15px;  /* å¢åŠ æŒ‰é’®å¤§å° */
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;     /* å¢åŠ å­—ä½“å¤§å° */
            transition: all 0.3s ease;
            flex: 1;
            text-align: center;
            min-height: 44px;    /* ç¡®ä¿è§¦æ‘¸å‹å¥½çš„æœ€å°é«˜åº¦ */
        }

        .axis-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-1px);
        }

        .axis-btn.x-axis {
            border-color: rgba(255, 99, 99, 0.5);
            background: rgba(255, 99, 99, 0.2);
        }

        .axis-btn.x-axis:hover {
            background: rgba(255, 99, 99, 0.4);
        }

        .axis-btn.y-axis {
            border-color: rgba(99, 255, 99, 0.5);
            background: rgba(99, 255, 99, 0.2);
        }

        .axis-btn.y-axis:hover {
            background: rgba(99, 255, 99, 0.4);
        }

        .axis-btn.z-axis {
            border-color: rgba(99, 99, 255, 0.5);
            background: rgba(99, 99, 255, 0.2);
        }

        .axis-btn.z-axis:hover {
            background: rgba(99, 99, 255, 0.4);
        }

        .rotation-speed {
            margin-top: 15px;
            text-align: center;
        }

        .rotation-speed label {
            display: block;
            margin-bottom: 5px;
            font-size: 11px;
            opacity: 0.8;
        }

        .rotation-speed input[type="range"] {
            width: 100%;
            accent-color: #4CAF50;
        }

        .rotation-speed span {
            font-size: 10px;
            opacity: 0.7;
        }

        .mobile-toggle {
            display: none;
            position: fixed;
            top: 10px;
            right: 70px;
            z-index: 150;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            font-size: 20px;
            cursor: pointer;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }

        .mobile-toggle:hover {
            background: rgba(0, 0, 0, 0.9);
            transform: scale(1.1);
        }

        .hide-all-toggle {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 200;
            background: rgba(220, 53, 69, 0.8);
            color: white;
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            font-size: 18px;
            cursor: pointer;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(220, 53, 69, 0.3);
        }

        .hide-all-toggle:hover {
            background: rgba(220, 53, 69, 1);
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(220, 53, 69, 0.5);
        }

        .hide-all-toggle.hidden-mode {
            background: rgba(40, 167, 69, 0.8);
            box-shadow: 0 4px 15px rgba(40, 167, 69, 0.3);
        }

        .hide-all-toggle.hidden-mode:hover {
            background: rgba(40, 167, 69, 1);
            box-shadow: 0 6px 20px rgba(40, 167, 69, 0.5);
        }

        /* ç§»åŠ¨ç«¯é€‚é… */
        @media (max-width: 768px) {
            .mobile-toggle {
                display: block;
            }
            
            .controls {
                position: fixed;
                bottom: 10px;
                right: 10px;
                top: auto;
                min-width: 120px;
                max-width: 200px;
                max-height: 40vh;
                padding: 12px;
                font-size: 11px;
                transform: translateX(100%);
                transition: transform 0.3s ease;
            }
            
            .controls.show {
                transform: translateX(0);
            }
            
            .controls .control-group button {
                padding: 6px 10px;
                font-size: 10px;
                margin-right: 3px;
                margin-bottom: 3px;
            }
            
            .axis-controls {
                left: 10px;
                min-width: 120px;
                max-width: 180px;
                padding: 12px;
                max-height: 70vh;
                overflow-y: auto;
                transform: translateX(-100%);
                transition: transform 0.3s ease;
            }
            
            .axis-controls.show {
                transform: translateX(0);
            }
            
            .axis-btn {
                padding: 8px 10px;
                font-size: 12px;
                min-height: 36px;
            }
            
            .axis-group {
                margin-bottom: 10px;
            }
            
            .axis-label {
                font-size: 10px;
                margin-bottom: 5px;
            }
            
            .header {
                top: 10px;
                left: 10px;
            }
            
            .header h1 {
                font-size: 18px;
            }
            
            .header p {
                font-size: 12px;
            }
            
            .instructions {
                display: none;
            }
            
            .file-upload {
                padding: 15px;
                max-width: 95%;
                margin: 10px;
            }
            
            .file-upload h2 {
                font-size: 20px;
                margin-bottom: 15px;
            }
            
            .file-upload p {
                font-size: 14px;
                margin-bottom: 15px;
            }
            
            .file-input-button {
                padding: 12px 20px;
                font-size: 14px;
            }
            
            .demo-button {
                padding: 10px 18px;
                font-size: 12px;
                margin: 5px;
            }
            
            /* ç¡®ä¿3Dè§†å›¾åŒºåŸŸä¸è¢«é®æŒ¡ */
            #canvas-container {
                padding-bottom: 80px; /* ä¸ºåº•éƒ¨æ§åˆ¶é¢æ¿ç•™å‡ºç©ºé—´ */
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <button class="mobile-toggle" id="mobileToggle" onclick="toggleMobileControls()">âš™ï¸</button>
        <button class="hide-all-toggle" id="hideAllToggle" onclick="toggleHideAll()" title="éšè—/æ˜¾ç¤ºæ‰€æœ‰æ“ä½œç•Œé¢">âœ–ï¸</button>
        
        <div class="header">
            <h1>ğŸš— é¹…ä¼´å°è½¦ 3D æ¨¡å‹</h1>
            <p>æŒ‰é”®æ“æ§ | ç§»åŠ¨ç«¯ä¼˜åŒ– | 6è‡ªç”±åº¦æ§åˆ¶</p>
        </div>

        <div class="axis-controls hidden" id="axis-controls">
            <h3>ğŸ¯ æ¨¡å‹æ§åˆ¶</h3>
            
            <!-- æ—‹è½¬æ§åˆ¶ -->
            <div style="margin-bottom: 20px;">
                <h4 style="color: #FFD700; margin-bottom: 10px; font-size: 12px;">ğŸ”„ æ—‹è½¬æ§åˆ¶</h4>
                
                <div class="axis-group">
                    <span class="axis-label">Xè½´ (çº¢è‰²)</span>
                    <div class="axis-buttons">
                        <button class="axis-btn x-axis" onclick="rotateModel('x', -1)">â†</button>
                        <button class="axis-btn x-axis" onclick="rotateModel('x', 1)">â†’</button>
                    </div>
                </div>
                
                <div class="axis-group">
                    <span class="axis-label">Yè½´ (ç»¿è‰²)</span>
                    <div class="axis-buttons">
                        <button class="axis-btn y-axis" onclick="rotateModel('y', -1)">â†“</button>
                        <button class="axis-btn y-axis" onclick="rotateModel('y', 1)">â†‘</button>
                    </div>
                </div>
                
                <div class="axis-group">
                    <span class="axis-label">Zè½´ (è“è‰²) - ä»…æŒ‰é’®æ§åˆ¶</span>
                    <div class="axis-buttons">
                        <button class="axis-btn z-axis" onclick="rotateModel('z', -1)" title="Zè½´é€†æ—¶é’ˆæ—‹è½¬">âŸ²</button>
                        <button class="axis-btn z-axis" onclick="rotateModel('z', 1)" title="Zè½´é¡ºæ—¶é’ˆæ—‹è½¬">âŸ³</button>
                    </div>
                </div>
            </div>
            
            <!-- ä½ç½®æ§åˆ¶ -->
            <div style="margin-bottom: 20px;">
                <h4 style="color: #00CED1; margin-bottom: 10px; font-size: 12px;">ğŸ“ ä½ç½®æ§åˆ¶</h4>
                
                <div class="axis-group">
                    <span class="axis-label">å·¦å³ç§»åŠ¨</span>
                    <div class="axis-buttons">
                        <button class="axis-btn" style="background: rgba(255, 165, 0, 0.2); border-color: rgba(255, 165, 0, 0.5);" onclick="moveModel('x', -1)">â†</button>
                        <button class="axis-btn" style="background: rgba(255, 165, 0, 0.2); border-color: rgba(255, 165, 0, 0.5);" onclick="moveModel('x', 1)">â†’</button>
                    </div>
                </div>
                
                <div class="axis-group">
                    <span class="axis-label">ä¸Šä¸‹ç§»åŠ¨</span>
                    <div class="axis-buttons">
                        <button class="axis-btn" style="background: rgba(255, 165, 0, 0.2); border-color: rgba(255, 165, 0, 0.5);" onclick="moveModel('y', -1)">â†“</button>
                        <button class="axis-btn" style="background: rgba(255, 165, 0, 0.2); border-color: rgba(255, 165, 0, 0.5);" onclick="moveModel('y', 1)">â†‘</button>
                    </div>
                </div>
                
                <div class="axis-group">
                    <span class="axis-label">å‰åç§»åŠ¨</span>
                    <div class="axis-buttons">
                        <button class="axis-btn" style="background: rgba(255, 165, 0, 0.2); border-color: rgba(255, 165, 0, 0.5);" onclick="moveModel('z', -1)">â¬‡</button>
                        <button class="axis-btn" style="background: rgba(255, 165, 0, 0.2); border-color: rgba(255, 165, 0, 0.5);" onclick="moveModel('z', 1)">â¬†</button>
                    </div>
                </div>
            </div>
            
            <div class="rotation-speed">
                <label>ç§»åŠ¨/æ—‹è½¬é€Ÿåº¦</label>
                <input type="range" id="rotationSpeed" min="0.5" max="5" step="0.5" value="2" onchange="updateRotationSpeed()">
                <span id="speedValue">2x</span>
            </div>
        </div>

        <div class="controls hidden" id="controls">
            <div class="control-group">
                <label>æ–‡ä»¶æ“ä½œ</label>
                <button onclick="showFileUpload()">ğŸ“‚ åŠ è½½æ–°æ¨¡å‹</button>
                <button onclick="resetCamera()">ğŸ”„ é‡ç½®è§†è§’</button>
                <button onclick="toggleWireframe()" id="wireframeBtn">ğŸ“ çº¿æ¡†æ¨¡å¼</button>
                <button onclick="toggleAxisControls()" id="axisControlBtn">ğŸ¯ æ¨¡å‹æ§åˆ¶</button>
            </div>
            
            <div class="control-group">
                <label>ç¼©æ”¾æ§åˆ¶</label>
                <button onclick="zoomIn()">ğŸ” æ”¾å¤§</button>
                <button onclick="zoomOut()">ğŸ” ç¼©å°</button>
                <button onclick="fitToScreen()">ğŸ“ é€‚åº”å±å¹•</button>
                <button onclick="resetModelRotation()">ğŸ”„ é‡ç½®ä½ç½®</button>
            </div>
            
            <div class="control-group">
                <label>å…‰ç…§å¼ºåº¦</label>
                <input type="range" id="lightIntensity" min="0" max="3" step="0.1" value="1.5" onchange="updateLighting()">
                <span id="lightValue">1.5</span>
            </div>
            
            <div class="control-group">
                <label>æ¨¡å‹é¢œè‰²</label>
                <button onclick="changeColor('#ff8c00')" style="background: #ff8c00;">é‡‘è‰²</button>
                <button onclick="changeColor('#4ecdc4')" style="background: #4ecdc4;">é’è‰²</button>
                <button onclick="changeColor('#45b7d1')" style="background: #45b7d1;">è“è‰²</button>
                <button onclick="changeColor('#96ceb4')" style="background: #96ceb4;">ç»¿è‰²</button>
                <button onclick="changeColor('#FF6103')" style="background: #FF6103;">æ©™è‰²</button>
                <button onclick="changeColor('#dda0dd')" style="background: #dda0dd;">ç´«è‰²</button>
            </div>
            
            <div class="control-group">
                <label>èƒŒæ™¯ä¸»é¢˜</label>
                <button onclick="changeBackground('gradient')" id="bgGradient" class="active">æ¸å˜</button>
                <button onclick="changeBackground('dark')" id="bgDark">æ·±è‰²</button>
                <button onclick="changeBackground('light')" id="bgLight">æµ…è‰²</button>
            </div>
        </div>

        <div id="file-upload" class="file-upload hidden">
            <h2>ğŸ“ é€‰æ‹©å…¶ä»– 3D æ¨¡å‹æ–‡ä»¶</h2>
            <p>æ”¯æŒ STL æ ¼å¼çš„ 3D æ¨¡å‹æ–‡ä»¶<br>
            æ–‡ä»¶å¤§å°å»ºè®®ä¸è¶…è¿‡ 50MB</p>
            
            <div class="file-input-wrapper">
                <input type="file" id="fileInput" class="file-input" accept=".stl" onchange="handleFileSelect(event)">
                <button class="file-input-button">ğŸ“‚ é€‰æ‹©æ–‡ä»¶</button>
            </div>
            
            <div class="drag-drop-area" id="dragDropArea">
                <p>æˆ–è€…å°† STL æ–‡ä»¶æ‹–æ‹½åˆ°è¿™é‡Œ</p>
            </div>
            
            <div style="margin-top: 20px;">
                <p style="font-size: 12px; opacity: 0.7;">
                    GitHub Pages éƒ¨ç½²ç‰ˆæœ¬ | 
                    <a href="https://github.com" target="_blank" style="color: #4CAF50;">æŸ¥çœ‹æºç </a>
                </p>
            </div>
        </div>

        <div id="loading" class="loading hidden">
            <div class="loading-spinner"></div>
            <p>æ­£åœ¨åŠ è½½ 3D æ¨¡å‹...</p>
        </div>

        <div id="error" class="error hidden">
            <h3>âŒ åŠ è½½å¤±è´¥</h3>
            <p id="error-message">æ— æ³•åŠ è½½ 3D æ¨¡å‹æ–‡ä»¶ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶æ ¼å¼æ˜¯å¦æ­£ç¡®ã€‚</p>
            <button class="demo-button" onclick="showFileUpload()" style="margin-top: 15px;">é‡æ–°é€‰æ‹©æ–‡ä»¶</button>
        </div>

        <div id="canvas-container"></div>

        <div class="instructions hidden" id="instructions">
            <h3>ğŸ® æ¨èï¼šæŒ‰é”®æ“æ§</h3>
            <ul>
                <li><strong>æ–¹å‘é”®ï¼šç§»åŠ¨æ¨¡å‹ä½ç½®</strong></li>
                <li><strong>Q/E/A/D/Z/Cï¼šæ—‹è½¬æ§åˆ¶</strong></li>
                <li>é¼ æ ‡å·¦é”®æ‹–æ‹½ï¼šX/Yè½´æ—‹è½¬è§†è§’</li>
                <li>é¼ æ ‡å³é”®æ‹–æ‹½ï¼šå¹³ç§»è§†è§’</li>
                <li>é¼ æ ‡æ»šè½®ï¼šç¼©æ”¾æ¨¡å‹</li>
                <li>åŒå‡»ï¼šå¿«é€Ÿé€‚åº”å±å¹•</li>
                <li>Té”®ï¼šæ˜¾ç¤º/éšè—æ¨¡å‹æ§åˆ¶</li>
                <li>Hé”®ï¼šéšè—/æ˜¾ç¤ºæ‰€æœ‰ç•Œé¢</li>
                <li>Shift+Rï¼šé‡ç½®ä½ç½®å’Œæ—‹è½¬</li>
                <li><strong>æ³¨æ„ï¼šZè½´æ—‹è½¬éœ€ä½¿ç”¨æŒ‰é’®æˆ–Z/Cé”®</strong></li>
            </ul>
        </div>

        <div id="zoom-info" class="zoom-info">
            ç¼©æ”¾: <span id="zoom-level">100%</span>
        </div>
    </div>

    <!-- Three.js åº“ - ä½¿ç”¨ç¨³å®šç‰ˆæœ¬ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // å†…åµŒSTLåŠ è½½å™¨ï¼Œé¿å…CDNé—®é¢˜
        THREE.STLLoader = function ( manager ) {
            this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
        };

        THREE.STLLoader.prototype = {
            constructor: THREE.STLLoader,
            
            load: function ( url, onLoad, onProgress, onError ) {
                var scope = this;
                var loader = new THREE.FileLoader( scope.manager );
                loader.setResponseType( 'arraybuffer' );
                loader.load( url, function ( text ) {
                    try {
                        onLoad( scope.parse( text ) );
                    } catch ( e ) {
                        if ( onError ) {
                            onError( e );
                        } else {
                            console.error( e );
                        }
                        scope.manager.itemError( url );
                    }
                }, onProgress, onError );
            },

            parse: function ( data ) {
                function isBinary( data ) {
                    var expect, face_size, n_faces, reader;
                    if ( data.byteLength < 80 ) return false;
                    reader = new DataView( data );
                    face_size = ( 32 / 8 * 3 ) + ( ( 32 / 8 * 3 ) * 3 ) + ( 16 / 8 );
                    n_faces = reader.getUint32( 80, true );
                    expect = 80 + ( 32 / 8 ) + ( n_faces * face_size );
                    if ( expect === reader.byteLength ) {
                        return true;
                    }
                    var fileLength = reader.byteLength;
                    for ( var index = 0; index < fileLength; index ++ ) {
                        if ( reader.getUint8( index, false ) > 127 ) {
                            return true;
                        }
                    }
                    return false;
                }

                function parseBinary( data ) {
                    var reader = new DataView( data );
                    var faces = reader.getUint32( 80, true );
                    var r, g, b, hasColors = false, colors;
                    var defaultR, defaultG, defaultB, alpha;
                    for ( var index = 0; index < 80 - 10; index ++ ) {
                        if ( ( reader.getUint32( index, false ) == 0x434F4C4F /*COLO*/ ) &&
                             ( reader.getUint8( index + 4 ) == 0x52 /*'R'*/ ) &&
                             ( reader.getUint8( index + 5 ) == 0x3D /*'='*/ ) ) {
                            hasColors = true;
                            colors = new Float32Array( faces * 3 * 3 );
                            defaultR = reader.getUint8( index + 6 ) / 255;
                            defaultG = reader.getUint8( index + 7 ) / 255;
                            defaultB = reader.getUint8( index + 8 ) / 255;
                            alpha = reader.getUint8( index + 9 ) / 255;
                        }
                    }
                    var dataOffset = 84;
                    var faceLength = 12 * 4 + 2;
                    var geometry = new THREE.BufferGeometry();
                    var vertices = new Float32Array( faces * 3 * 3 );
                    var normals = new Float32Array( faces * 3 * 3 );
                    for ( var face = 0; face < faces; face ++ ) {
                        var start = dataOffset + face * faceLength;
                        var normalX = reader.getFloat32( start, true );
                        var normalY = reader.getFloat32( start + 4, true );
                        var normalZ = reader.getFloat32( start + 8, true );
                        if ( hasColors ) {
                            var packedColor = reader.getUint16( start + 48, true );
                            if ( ( packedColor & 0x8000 ) === 0 ) {
                                r = ( packedColor & 0x1F ) / 31;
                                g = ( ( packedColor >> 5 ) & 0x1F ) / 31;
                                b = ( ( packedColor >> 10 ) & 0x1F ) / 31;
                            } else {
                                r = defaultR;
                                g = defaultG;
                                b = defaultB;
                            }
                        }
                        for ( var i = 1; i <= 3; i ++ ) {
                            var vertexstart = start + i * 12;
                            var componentIdx = ( face * 3 * 3 ) + ( ( i - 1 ) * 3 );
                            vertices[ componentIdx ] = reader.getFloat32( vertexstart, true );
                            vertices[ componentIdx + 1 ] = reader.getFloat32( vertexstart + 4, true );
                            vertices[ componentIdx + 2 ] = reader.getFloat32( vertexstart + 8, true );
                            normals[ componentIdx ] = normalX;
                            normals[ componentIdx + 1 ] = normalY;
                            normals[ componentIdx + 2 ] = normalZ;
                            if ( hasColors ) {
                                colors[ componentIdx ] = r;
                                colors[ componentIdx + 1 ] = g;
                                colors[ componentIdx + 2 ] = b;
                            }
                        }
                    }
                    geometry.setAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
                    geometry.setAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );
                    if ( hasColors ) {
                        geometry.setAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );
                        geometry.hasColors = true;
                        geometry.alpha = alpha;
                    }
                    return geometry;
                }

                function parseASCII( data ) {
                    var geometry = new THREE.BufferGeometry();
                    var patternSolid = /solid([\s\S]*?)endsolid/g;
                    var patternFace = /facet([\s\S]*?)endfacet/g;
                    var patternFloat = /[\s]+([+-]?(?:\d*)(?:\.\d*)?(?:[eE][+-]?\d+)?)[\s]+/g;
                    var result;
                    var groupVertices = [];
                    var groupNormals = [];
                    var text = '';
                    if ( data instanceof ArrayBuffer ) {
                        var view = new Uint8Array( data );
                        for ( var i = 0, l = view.length; i < l; i ++ ) {
                            text += String.fromCharCode( view[ i ] );
                        }
                    } else {
                        text = data;
                    }
                    while ( ( result = patternSolid.exec( text ) ) !== null ) {
                        var solid = result[ 0 ];
                        while ( ( result = patternFace.exec( solid ) ) !== null ) {
                            var face = result[ 0 ];
                            var vertices = [];
                            var normal = [];
                            patternFloat.lastIndex = 0;
                            while ( ( result = patternFloat.exec( face ) ) !== null ) {
                                vertices.push( parseFloat( result[ 1 ] ) );
                            }
                            normal.push( vertices[ 0 ], vertices[ 1 ], vertices[ 2 ] );
                            for ( var i = 3; i < 12; i += 3 ) {
                                groupVertices.push( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] );
                                groupNormals.push( normal[ 0 ], normal[ 1 ], normal[ 2 ] );
                            }
                        }
                    }
                    geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( groupVertices, 3 ) );
                    geometry.setAttribute( 'normal', new THREE.Float32BufferAttribute( groupNormals, 3 ) );
                    return geometry;
                }

                return isBinary( data ) ? parseBinary( data ) : parseASCII( data );
            }
        };
        
        // å†…åµŒè½¨é“æ§åˆ¶å™¨
        THREE.OrbitControls = function ( object, domElement ) {
            if ( domElement === undefined ) console.warn( 'THREE.OrbitControls: The second parameter "domElement" is now mandatory.' );
            if ( domElement === document ) console.error( 'THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.' );
            this.object = object;
            this.domElement = domElement;
            this.domElement.style.touchAction = 'none';
            this.enabled = true;
            this.target = new THREE.Vector3();
            this.minDistance = 0;
            this.maxDistance = Infinity;
            this.minZoom = 0;
            this.maxZoom = Infinity;
            this.minPolarAngle = 0;
            this.maxPolarAngle = Math.PI;
            this.minAzimuthAngle = - Infinity;
            this.maxAzimuthAngle = Infinity;
            this.enableDamping = false;
            this.dampingFactor = 0.05;
            this.enableZoom = true;
            this.zoomSpeed = 1.0;
            this.enableRotate = true;
            this.rotateSpeed = 1.0;
            this.enablePan = true;
            this.panSpeed = 1.0;
            this.screenSpacePanning = true;
            this.keyPanSpeed = 7.0;
            this.autoRotate = false;
            this.autoRotateSpeed = 2.0;
            this.keys = { LEFT: 'ArrowLeft', UP: 'ArrowUp', RIGHT: 'ArrowRight', BOTTOM: 'ArrowDown' };
            this.mouseButtons = { LEFT: THREE.MOUSE.ROTATE, MIDDLE: THREE.MOUSE.DOLLY, RIGHT: THREE.MOUSE.PAN };
            this.touches = { ONE: THREE.TOUCH.ROTATE, TWO: THREE.TOUCH.DOLLY_PAN };
            this.target0 = this.target.clone();
            this.position0 = this.object.position.clone();
            this.zoom0 = this.object.zoom;
            this._domElementKeyEvents = null;
            this.getPolarAngle = function () { return spherical.phi; };
            this.getAzimuthalAngle = function () { return spherical.theta; };
            this.getDistance = function () { return this.object.position.distanceTo( this.target ); };
            this.listenToKeyEvents = function ( domElement ) { domElement.addEventListener( 'keydown', onKeyDown ); this._domElementKeyEvents = domElement; };
            this.saveState = function () { scope.target0.copy( scope.target ); scope.position0.copy( scope.object.position ); scope.zoom0 = scope.object.zoom; };
            this.reset = function () { scope.target.copy( scope.target0 ); scope.object.position.copy( scope.position0 ); scope.object.zoom = scope.zoom0; scope.object.updateProjectionMatrix(); scope.dispatchEvent( changeEvent ); scope.update(); };
            this.update = function () {
                var offset = new THREE.Vector3();
                var quat = new THREE.Quaternion().setFromUnitVectors( object.up, new THREE.Vector3( 0, 1, 0 ) );
                var quatInverse = quat.clone().invert();
                var lastPosition = new THREE.Vector3();
                var lastQuaternion = new THREE.Quaternion();
                var twoPI = 2 * Math.PI;
                return function update() {
                    var position = scope.object.position;
                    offset.copy( position ).sub( scope.target );
                    offset.applyQuaternion( quat );
                    spherical.setFromVector3( offset );
                    if ( scope.autoRotate && state === STATE.NONE ) {
                        rotateLeft( getAutoRotationAngle() );
                    }
                    if ( scope.enableDamping ) {
                        spherical.theta += sphericalDelta.theta * scope.dampingFactor;
                        spherical.phi += sphericalDelta.phi * scope.dampingFactor;
                    } else {
                        spherical.theta += sphericalDelta.theta;
                        spherical.phi += sphericalDelta.phi;
                    }
                    spherical.theta = Math.max( scope.minAzimuthAngle, Math.min( scope.maxAzimuthAngle, spherical.theta ) );
                    spherical.phi = Math.max( scope.minPolarAngle, Math.min( scope.maxPolarAngle, spherical.phi ) );
                    spherical.makeSafe();
                    spherical.radius *= scale;
                    spherical.radius = Math.max( scope.minDistance, Math.min( scope.maxDistance, spherical.radius ) );
                    if ( scope.enableDamping === true ) {
                        scope.target.addScaledVector( panOffset, scope.dampingFactor );
                    } else {
                        scope.target.add( panOffset );
                    }
                    offset.setFromSpherical( spherical );
                    offset.applyQuaternion( quatInverse );
                    position.copy( scope.target ).add( offset );
                    scope.object.lookAt( scope.target );
                    if ( scope.enableDamping === true ) {
                        sphericalDelta.theta *= ( 1 - scope.dampingFactor );
                        sphericalDelta.phi *= ( 1 - scope.dampingFactor );
                        panOffset.multiplyScalar( 1 - scope.dampingFactor );
                    } else {
                        sphericalDelta.set( 0, 0, 0 );
                        panOffset.set( 0, 0, 0 );
                    }
                    scale = 1;
                    if ( zoomChanged || lastPosition.distanceToSquared( scope.object.position ) > EPS || 8 * ( 1 - lastQuaternion.dot( scope.object.quaternion ) ) > EPS ) {
                        scope.dispatchEvent( changeEvent );
                        lastPosition.copy( scope.object.position );
                        lastQuaternion.copy( scope.object.quaternion );
                        zoomChanged = false;
                        return true;
                    }
                    return false;
                };
            }();
            this.dispose = function () { scope.domElement.removeEventListener( 'contextmenu', onContextMenu ); scope.domElement.removeEventListener( 'pointerdown', onPointerDown ); scope.domElement.removeEventListener( 'pointercancel', onPointerCancel ); scope.domElement.removeEventListener( 'wheel', onMouseWheel ); scope.domElement.removeEventListener( 'pointermove', onPointerMove ); scope.domElement.removeEventListener( 'pointerup', onPointerUp ); if ( scope._domElementKeyEvents !== null ) { scope._domElementKeyEvents.removeEventListener( 'keydown', onKeyDown ); } };
            var scope = this;
            var changeEvent = { type: 'change' };
            var startEvent = { type: 'start' };
            var endEvent = { type: 'end' };
            var STATE = { NONE: - 1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_PAN: 4, TOUCH_DOLLY_PAN: 5, TOUCH_DOLLY_ROTATE: 6 };
            var state = STATE.NONE;
            var EPS = 0.000001;
            var spherical = new THREE.Spherical();
            var sphericalDelta = new THREE.Spherical();
            var scale = 1;
            var panOffset = new THREE.Vector3();
            var zoomChanged = false;
            var rotateStart = new THREE.Vector2();
            var rotateEnd = new THREE.Vector2();
            var rotateDelta = new THREE.Vector2();
            var panStart = new THREE.Vector2();
            var panEnd = new THREE.Vector2();
            var panDelta = new THREE.Vector2();
            var dollyStart = new THREE.Vector2();
            var dollyEnd = new THREE.Vector2();
            var dollyDelta = new THREE.Vector2();
            var pointers = [];
            var pointerPositions = {};
            function getAutoRotationAngle() { return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed; }
            function getZoomScale() { return Math.pow( 0.95, scope.zoomSpeed ); }
            function rotateLeft( angle ) { sphericalDelta.theta -= angle; }
            function rotateUp( angle ) { sphericalDelta.phi -= angle; }
            var panLeft = function () { var v = new THREE.Vector3(); return function panLeft( distance, objectMatrix ) { v.setFromMatrixColumn( objectMatrix, 0 ); v.multiplyScalar( - distance ); panOffset.add( v ); }; }();
            var panUp = function () { var v = new THREE.Vector3(); return function panUp( distance, objectMatrix ) { if ( scope.screenSpacePanning === true ) { v.setFromMatrixColumn( objectMatrix, 1 ); } else { v.setFromMatrixColumn( objectMatrix, 0 ); v.crossVectors( scope.object.up, v ); } v.multiplyScalar( distance ); panOffset.add( v ); }; }();
            var pan = function () { var offset = new THREE.Vector3(); return function pan( deltaX, deltaY ) { var element = scope.domElement; if ( scope.object.isPerspectiveCamera ) { var position = scope.object.position; offset.copy( position ).sub( scope.target ); var targetDistance = offset.length(); targetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 ); panLeft( 2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix ); panUp( 2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix ); } else if ( scope.object.isOrthographicCamera ) { panLeft( deltaX * ( scope.object.right - scope.object.left ) / scope.object.zoom / element.clientWidth, scope.object.matrix ); panUp( deltaY * ( scope.object.top - scope.object.bottom ) / scope.object.zoom / element.clientHeight, scope.object.matrix ); } else { console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' ); scope.enablePan = false; } }; }();
            function dollyOut( dollyScale ) { if ( scope.object.isPerspectiveCamera ) { scale /= dollyScale; } else if ( scope.object.isOrthographicCamera ) { scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom * dollyScale ) ); scope.object.updateProjectionMatrix(); zoomChanged = true; } else { console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' ); scope.enableZoom = false; } }
            function dollyIn( dollyScale ) { if ( scope.object.isPerspectiveCamera ) { scale *= dollyScale; } else if ( scope.object.isOrthographicCamera ) { scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / dollyScale ) ); scope.object.updateProjectionMatrix(); zoomChanged = true; } else { console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' ); scope.enableZoom = false; } }
            function handleMouseDownRotate( event ) { rotateStart.set( event.clientX, event.clientY ); }
            function handleMouseDownDolly( event ) { dollyStart.set( event.clientX, event.clientY ); }
            function handleMouseDownPan( event ) { panStart.set( event.clientX, event.clientY ); }
            function handleMouseMoveRotate( event ) { rotateEnd.set( event.clientX, event.clientY ); rotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed ); var element = scope.domElement; rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight ); rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight ); rotateStart.copy( rotateEnd ); scope.update(); }
            function handleMouseMoveDolly( event ) { dollyEnd.set( event.clientX, event.clientY ); dollyDelta.subVectors( dollyEnd, dollyStart ); if ( dollyDelta.y > 0 ) { dollyOut( getZoomScale() ); } else if ( dollyDelta.y < 0 ) { dollyIn( getZoomScale() ); } dollyStart.copy( dollyEnd ); scope.update(); }
            function handleMouseMovePan( event ) { panEnd.set( event.clientX, event.clientY ); panDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed ); pan( panDelta.x, panDelta.y ); panStart.copy( panEnd ); scope.update(); }
            function handleMouseWheel( event ) { if ( event.deltaY < 0 ) { dollyIn( getZoomScale() ); } else if ( event.deltaY > 0 ) { dollyOut( getZoomScale() ); } scope.update(); }
            function handleKeyDown( event ) { var needsUpdate = false; switch ( event.code ) { case scope.keys.UP: pan( 0, scope.keyPanSpeed ); needsUpdate = true; break; case scope.keys.BOTTOM: pan( 0, - scope.keyPanSpeed ); needsUpdate = true; break; case scope.keys.LEFT: pan( scope.keyPanSpeed, 0 ); needsUpdate = true; break; case scope.keys.RIGHT: pan( - scope.keyPanSpeed, 0 ); needsUpdate = true; break; } if ( needsUpdate ) { event.preventDefault(); scope.update(); } }
            function handleTouchStartRotate() { if ( pointers.length === 1 ) { rotateStart.set( pointers[ 0 ].pageX, pointers[ 0 ].pageY ); } else { var x = 0.5 * ( pointers[ 0 ].pageX + pointers[ 1 ].pageX ); var y = 0.5 * ( pointers[ 0 ].pageY + pointers[ 1 ].pageY ); rotateStart.set( x, y ); } }
            function handleTouchStartPan() { if ( pointers.length === 1 ) { panStart.set( pointers[ 0 ].pageX, pointers[ 0 ].pageY ); } else { var x = 0.5 * ( pointers[ 0 ].pageX + pointers[ 1 ].pageX ); var y = 0.5 * ( pointers[ 0 ].pageY + pointers[ 1 ].pageY ); panStart.set( x, y ); } }
            function handleTouchStartDolly() { var dx = pointers[ 0 ].pageX - pointers[ 1 ].pageX; var dy = pointers[ 0 ].pageY - pointers[ 1 ].pageY; var distance = Math.sqrt( dx * dx + dy * dy ); dollyStart.set( 0, distance ); }
            function handleTouchStartDollyPan() { if ( scope.enableZoom ) handleTouchStartDolly(); if ( scope.enablePan ) handleTouchStartPan(); }
            function handleTouchStartDollyRotate() { if ( scope.enableZoom ) handleTouchStartDolly(); if ( scope.enableRotate ) handleTouchStartRotate(); }
            function handleTouchMoveRotate( event ) { if ( pointers.length == 1 ) { rotateEnd.set( event.pageX, event.pageY ); } else { var position = getSecondPointerPosition( event ); var x = 0.5 * ( event.pageX + position.x ); var y = 0.5 * ( event.pageY + position.y ); rotateEnd.set( x, y ); } rotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed ); var element = scope.domElement; rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight ); rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight ); rotateStart.copy( rotateEnd ); }
            function handleTouchMovePan( event ) { if ( pointers.length === 1 ) { panEnd.set( event.pageX, event.pageY ); } else { var position = getSecondPointerPosition( event ); var x = 0.5 * ( event.pageX + position.x ); var y = 0.5 * ( event.pageY + position.y ); panEnd.set( x, y ); } panDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed ); pan( panDelta.x, panDelta.y ); panStart.copy( panEnd ); }
            function handleTouchMoveDolly( event ) { var position = getSecondPointerPosition( event ); var dx = event.pageX - position.x; var dy = event.pageY - position.y; var distance = Math.sqrt( dx * dx + dy * dy ); dollyEnd.set( 0, distance ); dollyDelta.set( 0, Math.pow( dollyEnd.y / dollyStart.y, scope.zoomSpeed ) ); dollyOut( dollyDelta.y ); dollyStart.copy( dollyEnd ); }
            function handleTouchMoveDollyPan( event ) { if ( scope.enableZoom ) handleTouchMoveDolly( event ); if ( scope.enablePan ) handleTouchMovePan( event ); }
            function handleTouchMoveDollyRotate( event ) { if ( scope.enableZoom ) handleTouchMoveDolly( event ); if ( scope.enableRotate ) handleTouchMoveRotate( event ); }
            function onPointerDown( event ) { if ( scope.enabled === false ) return; if ( pointers.length === 0 ) { scope.domElement.setPointerCapture( event.pointerId ); scope.domElement.addEventListener( 'pointermove', onPointerMove ); scope.domElement.addEventListener( 'pointerup', onPointerUp ); } addPointer( event ); if ( event.pointerType === 'touch' ) { onTouchStart( event ); } else { onMouseDown( event ); } }
            function onPointerMove( event ) { if ( scope.enabled === false ) return; if ( event.pointerType === 'touch' ) { onTouchMove( event ); } else { onMouseMove( event ); } }
            function onPointerUp( event ) { removePointer( event ); if ( pointers.length === 0 ) { scope.domElement.releasePointerCapture( event.pointerId ); scope.domElement.removeEventListener( 'pointermove', onPointerMove ); scope.domElement.removeEventListener( 'pointerup', onPointerUp ); } scope.dispatchEvent( endEvent ); state = STATE.NONE; }
            function onPointerCancel( event ) { removePointer( event ); }
            function onMouseDown( event ) { var mouseAction; switch ( event.button ) { case 0: mouseAction = scope.mouseButtons.LEFT; break; case 1: mouseAction = scope.mouseButtons.MIDDLE; break; case 2: mouseAction = scope.mouseButtons.RIGHT; break; default: mouseAction = - 1; } switch ( mouseAction ) { case THREE.MOUSE.DOLLY: if ( scope.enableZoom === false ) return; handleMouseDownDolly( event ); state = STATE.DOLLY; break; case THREE.MOUSE.ROTATE: if ( event.ctrlKey || event.metaKey || event.shiftKey ) { if ( scope.enablePan === false ) return; handleMouseDownPan( event ); state = STATE.PAN; } else { if ( scope.enableRotate === false ) return; handleMouseDownRotate( event ); state = STATE.ROTATE; } break; case THREE.MOUSE.PAN: if ( event.ctrlKey || event.metaKey || event.shiftKey ) { if ( scope.enableRotate === false ) return; handleMouseDownRotate( event ); state = STATE.ROTATE; } else { if ( scope.enablePan === false ) return; handleMouseDownPan( event ); state = STATE.PAN; } break; default: state = STATE.NONE; } if ( state !== STATE.NONE ) { scope.dispatchEvent( startEvent ); } }
            function onMouseMove( event ) { if ( scope.enabled === false ) return; switch ( state ) { case STATE.ROTATE: if ( scope.enableRotate === false ) return; handleMouseMoveRotate( event ); break; case STATE.DOLLY: if ( scope.enableZoom === false ) return; handleMouseMoveDolly( event ); break; case STATE.PAN: if ( scope.enablePan === false ) return; handleMouseMovePan( event ); break; } }
            function onMouseWheel( event ) { if ( scope.enabled === false || scope.enableZoom === false || ( state !== STATE.NONE && state !== STATE.ROTATE ) ) return; event.preventDefault(); scope.dispatchEvent( startEvent ); handleMouseWheel( event ); scope.dispatchEvent( endEvent ); }
            function onKeyDown( event ) { if ( scope.enabled === false || scope.enablePan === false ) return; handleKeyDown( event ); }
            function onTouchStart( event ) { trackPointer( event ); switch ( pointers.length ) { case 1: switch ( scope.touches.ONE ) { case THREE.TOUCH.ROTATE: if ( scope.enableRotate === false ) return; handleTouchStartRotate(); state = STATE.TOUCH_ROTATE; break; case THREE.TOUCH.PAN: if ( scope.enablePan === false ) return; handleTouchStartPan(); state = STATE.TOUCH_PAN; break; default: state = STATE.NONE; } break; case 2: switch ( scope.touches.TWO ) { case THREE.TOUCH.DOLLY_PAN: if ( scope.enableZoom === false && scope.enablePan === false ) return; handleTouchStartDollyPan(); state = STATE.TOUCH_DOLLY_PAN; break; case THREE.TOUCH.DOLLY_ROTATE: if ( scope.enableZoom === false && scope.enableRotate === false ) return; handleTouchStartDollyRotate(); state = STATE.TOUCH_DOLLY_ROTATE; break; default: state = STATE.NONE; } break; default: state = STATE.NONE; } if ( state !== STATE.NONE ) { scope.dispatchEvent( startEvent ); } }
            function onTouchMove( event ) { trackPointer( event ); switch ( state ) { case STATE.TOUCH_ROTATE: if ( scope.enableRotate === false ) return; handleTouchMoveRotate( event ); scope.update(); break; case STATE.TOUCH_PAN: if ( scope.enablePan === false ) return; handleTouchMovePan( event ); scope.update(); break; case STATE.TOUCH_DOLLY_PAN: if ( scope.enableZoom === false && scope.enablePan === false ) return; handleTouchMoveDollyPan( event ); scope.update(); break; case STATE.TOUCH_DOLLY_ROTATE: if ( scope.enableZoom === false && scope.enableRotate === false ) return; handleTouchMoveDollyRotate( event ); scope.update(); break; default: state = STATE.NONE; } }
            function onContextMenu( event ) { if ( scope.enabled === false ) return; event.preventDefault(); }
            function addPointer( event ) { pointers.push( event ); }
            function removePointer( event ) { delete pointerPositions[ event.pointerId ]; for ( var i = 0; i < pointers.length; i ++ ) { if ( pointers[ i ].pointerId == event.pointerId ) { pointers.splice( i, 1 ); return; } } }
            function trackPointer( event ) { var position = pointerPositions[ event.pointerId ]; if ( position === undefined ) { position = new THREE.Vector2(); pointerPositions[ event.pointerId ] = position; } position.set( event.pageX, event.pageY ); }
            function getSecondPointerPosition( event ) { var pointer = ( event.pointerId === pointers[ 0 ].pointerId ) ? pointers[ 1 ] : pointers[ 0 ]; return pointerPositions[ pointer.pointerId ]; }
            scope.domElement.addEventListener( 'contextmenu', onContextMenu );
            scope.domElement.addEventListener( 'pointerdown', onPointerDown );
            scope.domElement.addEventListener( 'pointercancel', onPointerCancel );
            scope.domElement.addEventListener( 'wheel', onMouseWheel );
            scope.update();
        };
        THREE.OrbitControls.prototype = Object.create( THREE.EventDispatcher.prototype );
        THREE.OrbitControls.prototype.constructor = THREE.OrbitControls;
        
        console.log('âœ“ STLåŠ è½½å™¨å’Œè½¨é“æ§åˆ¶å™¨å·²å†…åµŒ');
    </script>

    <script>
        // å…¨å±€å˜é‡
        let scene, camera, renderer, controls;
        let model, originalMaterial;
        let ambientLight, directionalLight;
        let isWireframe = false;
        let modelBoundingBox, modelSize, modelCenter;
        let initialCameraDistance = 10;
        let zoomLevel = 1;
        let rotationSpeed = 2;
        let isAxisControlsVisible = true;  // é»˜è®¤æ˜¾ç¤ºæ§åˆ¶é¢æ¿

        // åˆå§‹åŒ– 3D åœºæ™¯
        function init() {
            console.log('=== å¼€å§‹åˆå§‹åŒ– 3D åœºæ™¯ ===');
            
            // æ£€æŸ¥Three.jsæ˜¯å¦åŠ è½½
            if (typeof THREE === 'undefined') {
                console.error('Three.js åº“æœªåŠ è½½ï¼');
                showError('Three.js åº“åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥ï¼');
                return;
            }
            console.log('âœ“ Three.js åº“å·²åŠ è½½ï¼Œç‰ˆæœ¬:', THREE.REVISION);
            
            // æ£€æŸ¥STLLoaderæ˜¯å¦åŠ è½½
            if (typeof THREE.STLLoader === 'undefined') {
                console.error('STLLoader æœªåŠ è½½ï¼');
                showError('STLåŠ è½½å™¨æœªæ‰¾åˆ°ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥ï¼');
                return;
            }
            console.log('âœ“ STLLoader å·²åŠ è½½');
            
            // æ£€æŸ¥OrbitControlsæ˜¯å¦åŠ è½½
            if (typeof THREE.OrbitControls === 'undefined') {
                console.error('OrbitControls æœªåŠ è½½ï¼');
                showError('è½¨é“æ§åˆ¶å™¨æœªæ‰¾åˆ°ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥ï¼');
                return;
            }
            console.log('âœ“ OrbitControls å·²åŠ è½½');
            
            // åˆ›å»ºåœºæ™¯
            scene = new THREE.Scene();
            console.log('âœ“ åœºæ™¯åˆ›å»ºå®Œæˆ');
            
            // åˆ›å»ºç›¸æœº - ä¼˜åŒ–è§†è§’å‚æ•°
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.01, 10000);
            camera.position.set(5, 5, 5);
            console.log('âœ“ ç›¸æœºåˆ›å»ºå®Œæˆ');
            
            // åˆ›å»ºæ¸²æŸ“å™¨ - ä¼˜åŒ–æ¸²æŸ“å‚æ•°
            renderer = new THREE.WebGLRenderer({ 
                antialias: true, 
                alpha: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setClearColor(0x000000, 0);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            console.log('âœ“ æ¸²æŸ“å™¨åˆ›å»ºå®Œæˆ');
            
            // å°†æ¸²æŸ“å™¨æ·»åŠ åˆ°é¡µé¢
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            console.log('âœ“ æ¸²æŸ“å™¨å·²æ·»åŠ åˆ°é¡µé¢');
            
            // åˆ›å»ºè½¨é“æ§åˆ¶å™¨ - ä¼˜åŒ–ç¼©æ”¾å‚æ•°å’ŒZè½´æ§åˆ¶
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = true;  // å¯ç”¨å±å¹•ç©ºé—´å¹³ç§»
            controls.enablePan = true;           // ç¡®ä¿å¹³ç§»åŠŸèƒ½å¯ç”¨
            controls.enableRotate = true;        // ç¡®ä¿æ—‹è½¬åŠŸèƒ½å¯ç”¨
            controls.enableZoom = true;          // ç¡®ä¿ç¼©æ”¾åŠŸèƒ½å¯ç”¨
            controls.minDistance = 0.1;
            controls.maxDistance = 1000;
            controls.maxPolarAngle = Math.PI;
            
            // ä¼˜åŒ–ç¼©æ”¾å‚æ•°
            controls.zoomSpeed = 1.2;
            controls.panSpeed = 1.0;             // å¢åŠ å¹³ç§»é€Ÿåº¦
            controls.rotateSpeed = 0.5;
            
            // å¯ç”¨æ‰€æœ‰é¼ æ ‡æŒ‰é”®åŠŸèƒ½
            controls.mouseButtons = {
                LEFT: THREE.MOUSE.ROTATE,    // å·¦é”®æ—‹è½¬
                MIDDLE: THREE.MOUSE.DOLLY,   // ä¸­é”®ç¼©æ”¾
                RIGHT: THREE.MOUSE.PAN       // å³é”®å¹³ç§»
            };
            
            // å¯ç”¨è§¦æ‘¸æ§åˆ¶ï¼ˆç§»åŠ¨ç«¯ï¼‰
            controls.touches = {
                ONE: THREE.TOUCH.ROTATE,     // å•æŒ‡æ—‹è½¬
                TWO: THREE.TOUCH.DOLLY_PAN   // åŒæŒ‡ç¼©æ”¾å’Œå¹³ç§»
            };
            
            // ç›‘å¬æ§åˆ¶å™¨å˜åŒ–
            controls.addEventListener('change', updateZoomInfo);
            console.log('âœ“ è½¨é“æ§åˆ¶å™¨åˆ›å»ºå®Œæˆ');
            
            // è®¾ç½®å…‰ç…§
            setupLighting();
            console.log('âœ“ å…‰ç…§è®¾ç½®å®Œæˆ');
            
            // ç›‘å¬çª—å£å¤§å°å˜åŒ–
            window.addEventListener('resize', onWindowResize, false);
            
            // è®¾ç½®æ‹–æ‹½åŠŸèƒ½
            setupDragDrop();
            console.log('âœ“ æ‹–æ‹½åŠŸèƒ½è®¾ç½®å®Œæˆ');
            
            // æ·»åŠ åŒå‡»äº‹ä»¶
            renderer.domElement.addEventListener('dblclick', fitToScreen);
            
            // ç›´æ¥åŠ è½½é»˜è®¤æ¨¡å‹
            console.log('å‡†å¤‡åŠ è½½é»˜è®¤æ¨¡å‹...');
            loadDefaultModel();
            
            // å¼€å§‹æ¸²æŸ“å¾ªç¯
            animate();
            console.log('âœ“ æ¸²æŸ“å¾ªç¯å·²å¯åŠ¨');
            console.log('=== 3D åœºæ™¯åˆå§‹åŒ–å®Œæˆ ===');
        }

        // è®¾ç½®å…‰ç…§ - ä¼˜åŒ–å…‰ç…§æ•ˆæœ
        function setupLighting() {
            // ç¯å¢ƒå…‰
            ambientLight = new THREE.AmbientLight(0x404040, 0.8);
            scene.add(ambientLight);
            
            // ä¸»æ–¹å‘å…‰
            directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 500;
            scene.add(directionalLight);
            
            // è¡¥å……å…‰æº
            const light2 = new THREE.DirectionalLight(0xffffff, 0.8);
            light2.position.set(-10, -10, -5);
            scene.add(light2);
            
            // é¡¶éƒ¨å…‰æº
            const light3 = new THREE.DirectionalLight(0xffffff, 0.6);
            light3.position.set(0, 20, 0);
            scene.add(light3);
        }

        // è®¾ç½®æ‹–æ‹½åŠŸèƒ½
        function setupDragDrop() {
            const dragDropArea = document.getElementById('dragDropArea');
            
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                dragDropArea.addEventListener(eventName, preventDefaults, false);
                document.body.addEventListener(eventName, preventDefaults, false);
            });

            ['dragenter', 'dragover'].forEach(eventName => {
                dragDropArea.addEventListener(eventName, highlight, false);
            });

            ['dragleave', 'drop'].forEach(eventName => {
                dragDropArea.addEventListener(eventName, unhighlight, false);
            });

            dragDropArea.addEventListener('drop', handleDrop, false);

            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }

            function highlight(e) {
                dragDropArea.classList.add('dragover');
            }

            function unhighlight(e) {
                dragDropArea.classList.remove('dragover');
            }

            function handleDrop(e) {
                const dt = e.dataTransfer;
                const files = dt.files;
                if (files.length > 0) {
                    loadSTLFromFile(files[0]);
                }
            }
        }

        // å¤„ç†æ–‡ä»¶é€‰æ‹©
        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (file) {
                loadSTLFromFile(file);
            }
        }

        // ä»æ–‡ä»¶åŠ è½½ STL æ¨¡å‹
        function loadSTLFromFile(file) {
            if (!file.name.toLowerCase().endsWith('.stl')) {
                showError('è¯·é€‰æ‹© STL æ ¼å¼çš„æ–‡ä»¶ï¼');
                return;
            }

            if (file.size > 50 * 1024 * 1024) { // 50MB é™åˆ¶
                showError('æ–‡ä»¶å¤ªå¤§ï¼è¯·é€‰æ‹©å°äº 50MB çš„æ–‡ä»¶ã€‚');
                return;
            }

            showLoading();
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const arrayBuffer = e.target.result;
                loadSTLFromArrayBuffer(arrayBuffer);
            };
            reader.onerror = function() {
                showError('æ–‡ä»¶è¯»å–å¤±è´¥ï¼Œè¯·é‡è¯•ï¼');
            };
            reader.readAsArrayBuffer(file);
        }

        // ä» ArrayBuffer åŠ è½½ STL
        function loadSTLFromArrayBuffer(arrayBuffer) {
            const loader = new THREE.STLLoader();
            
            try {
                const geometry = loader.parse(arrayBuffer);
                createModelFromGeometry(geometry);
            } catch (error) {
                console.error('STL è§£æå¤±è´¥:', error);
                showError('STL æ–‡ä»¶æ ¼å¼é”™è¯¯ï¼Œæ— æ³•è§£æï¼');
            }
        }

        // åŠ è½½é»˜è®¤æ¨¡å‹
        function loadDefaultModel() {
            console.log('å¼€å§‹åŠ è½½é»˜è®¤æ¨¡å‹: é¹…ä¼´å°è½¦.stl');
            showLoading();
            
            const loader = new THREE.STLLoader();
            loader.load(
                'é¹…ä¼´å°è½¦.stl',
                function (geometry) {
                    console.log('é»˜è®¤æ¨¡å‹åŠ è½½æˆåŠŸï¼');
                    createModelFromGeometry(geometry);
                },
                function (progress) {
                    if (progress.total > 0) {
                        const percent = (progress.loaded / progress.total * 100).toFixed(1);
                        console.log('åŠ è½½è¿›åº¦:', percent + '%');
                    }
                },
                function (error) {
                    console.error('é»˜è®¤æ¨¡å‹åŠ è½½å¤±è´¥:', error);
                    console.log('å°è¯•æ˜¾ç¤ºæ–‡ä»¶ä¸Šä¼ ç•Œé¢');
                    showFileUpload();
                }
            );
        }

        // ä»å‡ ä½•ä½“åˆ›å»ºæ¨¡å‹ - ä¼˜åŒ–ç¼©æ”¾é€»è¾‘å’Œç§»åŠ¨ç«¯é€‚é…
        function createModelFromGeometry(geometry) {
            // æ¸…é™¤ç°æœ‰æ¨¡å‹
            if (model) {
                scene.remove(model);
                model.geometry.dispose();
                model.material.dispose();
            }
            
            // è®¡ç®—å‡ ä½•ä½“çš„æ³•å‘é‡
            geometry.computeVertexNormals();
            
            // åˆ›å»ºæè´¨ - åˆå§‹é¢œè‰²è®¾ä¸ºæ©™è‰²
            const material = new THREE.MeshPhongMaterial({
                color: 0xFF6103,  // æ©™è‰² RGB(255,97,3)
                shininess: 100,
                specular: 0x111111,
                side: THREE.DoubleSide
            });
            
            // åˆ›å»ºç½‘æ ¼
            model = new THREE.Mesh(geometry, material);
            originalMaterial = material;
            
            // å¯ç”¨é˜´å½±
            model.castShadow = true;
            model.receiveShadow = true;
            
            // è®¡ç®—æ¨¡å‹çš„è¾¹ç•Œç›’å’Œå°ºå¯¸
            modelBoundingBox = new THREE.Box3().setFromObject(model);
            modelCenter = modelBoundingBox.getCenter(new THREE.Vector3());
            modelSize = modelBoundingBox.getSize(new THREE.Vector3());
            
            // å°†æ¨¡å‹å±…ä¸­
            model.position.sub(modelCenter);
            
            // è®¾ç½®åˆå§‹æ—‹è½¬ï¼šXè½´å‡90åº¦ï¼ˆåŸºç¡€æ—‹è½¬ï¼‰
            model.rotation.x = -Math.PI / 2;
            
            // åˆå§‹ä½ç½®ä¿æŒåœ¨åŸç‚¹(0,0,0)ï¼Œé‡ç½®æ—¶æ‰ç§»åŠ¨åˆ°è°ƒæ•´ä½ç½®
            
            // è®¡ç®—åˆé€‚çš„ç›¸æœºè·ç¦» - é’ˆå¯¹ç§»åŠ¨ç«¯ä¼˜åŒ–
            const maxDim = Math.max(modelSize.x, modelSize.y, modelSize.z);
            
            // æ£€æµ‹æ˜¯å¦ä¸ºç§»åŠ¨è®¾å¤‡
            const isMobile = window.innerWidth <= 768;
            
            // ç§»åŠ¨ç«¯ä½¿ç”¨æ›´å¤§çš„è·ç¦»å€æ•°ï¼Œç¡®ä¿æ¨¡å‹ä¸ä¼šå¤ªå¤§
            const distanceMultiplier = isMobile ? 3.5 : 2.5;
            initialCameraDistance = maxDim * distanceMultiplier;
            
            // è®¾ç½®ç›¸æœºå‚æ•°
            camera.near = maxDim * 0.001;
            camera.far = maxDim * 100;
            camera.updateProjectionMatrix();
            
            // è®¾ç½®æ§åˆ¶å™¨è·ç¦»é™åˆ¶
            controls.minDistance = maxDim * 0.2;
            controls.maxDistance = maxDim * 15;
            
            // æ·»åŠ åˆ°åœºæ™¯
            scene.add(model);
            
            // é€‚åº”å±å¹•
            fitToScreen();
            
            // æ˜¾ç¤ºæ¨¡å‹è§†å›¾
            showModelView();
            
            console.log('æ¨¡å‹åŠ è½½æˆåŠŸ');
            console.log('æ¨¡å‹å°ºå¯¸:', modelSize);
            console.log('åˆå§‹ç›¸æœºè·ç¦»:', initialCameraDistance);
            console.log('ç§»åŠ¨ç«¯æ¨¡å¼:', isMobile);
            console.log('åˆå§‹çŠ¶æ€: Xè½´-90Â°, ä½ç½®(0,0,0), æ©™è‰²');
            console.log('é‡ç½®çŠ¶æ€: Xè½´-90Â°+Zè½´15Â°, ä½ç½®(å·¦4æ¬¡,ä¸‹4æ¬¡,0)');
        }

        // é€‚åº”å±å¹• - ä¼˜åŒ–çš„ç¼©æ”¾é€»è¾‘ï¼Œç§»åŠ¨ç«¯å‹å¥½
        function fitToScreen() {
            if (!model) return;
            
            const maxDim = Math.max(modelSize.x, modelSize.y, modelSize.z);
            const fov = camera.fov * (Math.PI / 180);
            
            // æ£€æµ‹ç§»åŠ¨è®¾å¤‡
            const isMobile = window.innerWidth <= 768;
            
            // ç§»åŠ¨ç«¯ä½¿ç”¨æ›´å¤§çš„è·ç¦»å€æ•°ï¼Œç¡®ä¿æ¨¡å‹é€‚ä¸­
            const screenMultiplier = isMobile ? 1.8 : 1.2;
            const distance = maxDim / (2 * Math.tan(fov / 2)) * screenMultiplier;
            
            // è®¾ç½®ç›¸æœºä½ç½®
            const direction = camera.position.clone().normalize();
            camera.position.copy(direction.multiplyScalar(distance));
            
            // æ›´æ–°æ§åˆ¶å™¨
            controls.target.set(0, 0, 0);
            controls.update();
            
            // é‡ç½®ç¼©æ”¾çº§åˆ«
            zoomLevel = 1;
            updateZoomInfo();
        }

        // æ”¾å¤§
        function zoomIn() {
            if (!model) return;
            const currentDistance = camera.position.distanceTo(controls.target);
            const newDistance = currentDistance * 0.8;
            if (newDistance > controls.minDistance) {
                const direction = camera.position.clone().sub(controls.target).normalize();
                camera.position.copy(controls.target).add(direction.multiplyScalar(newDistance));
                controls.update();
                updateZoomInfo();
            }
        }

        // ç¼©å°
        function zoomOut() {
            if (!model) return;
            const currentDistance = camera.position.distanceTo(controls.target);
            const newDistance = currentDistance * 1.25;
            if (newDistance < controls.maxDistance) {
                const direction = camera.position.clone().sub(controls.target).normalize();
                camera.position.copy(controls.target).add(direction.multiplyScalar(newDistance));
                controls.update();
                updateZoomInfo();
            }
        }

        // æ›´æ–°ç¼©æ”¾ä¿¡æ¯æ˜¾ç¤º
        function updateZoomInfo() {
            if (!model) return;
            
            const currentDistance = camera.position.distanceTo(controls.target);
            zoomLevel = initialCameraDistance / currentDistance;
            
            const zoomPercentage = Math.round(zoomLevel * 100);
            document.getElementById('zoom-level').textContent = zoomPercentage + '%';
            
            // æ˜¾ç¤ºç¼©æ”¾ä¿¡æ¯
            const zoomInfo = document.getElementById('zoom-info');
            zoomInfo.classList.add('show');
            
            // 3ç§’åéšè—
            clearTimeout(window.zoomInfoTimeout);
            window.zoomInfoTimeout = setTimeout(() => {
                zoomInfo.classList.remove('show');
            }, 3000);
        }

        // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
        function showLoading() {
            console.log('æ˜¾ç¤ºåŠ è½½ç•Œé¢');
            document.getElementById('file-upload').classList.add('hidden');
            document.getElementById('loading').classList.remove('hidden');
            document.getElementById('error').classList.add('hidden');
        }

        // æ˜¾ç¤ºé”™è¯¯ä¿¡æ¯
        function showError(message) {
            document.getElementById('file-upload').classList.add('hidden');
            document.getElementById('loading').classList.add('hidden');
            document.getElementById('error').classList.remove('hidden');
            document.getElementById('error-message').textContent = message;
        }

        // æ˜¾ç¤ºæ–‡ä»¶ä¸Šä¼ ç•Œé¢
        function showFileUpload() {
            document.getElementById('file-upload').classList.remove('hidden');
            document.getElementById('loading').classList.add('hidden');
            document.getElementById('error').classList.add('hidden');
            document.getElementById('controls').classList.add('hidden');
            document.getElementById('instructions').classList.add('hidden');
            document.getElementById('zoom-info').classList.remove('show');
        }

        // æ˜¾ç¤ºæ¨¡å‹è§†å›¾
        function showModelView() {
            console.log('æ˜¾ç¤ºæ¨¡å‹è§†å›¾');
            document.getElementById('file-upload').classList.add('hidden');
            document.getElementById('loading').classList.add('hidden');
            document.getElementById('error').classList.add('hidden');
            document.getElementById('controls').classList.remove('hidden');
            document.getElementById('instructions').classList.remove('hidden');
            
            // æ£€æµ‹ç§»åŠ¨è®¾å¤‡
            const isMobile = window.innerWidth <= 768;
            
            if (isMobile) {
                // ç§»åŠ¨ç«¯ï¼šé»˜è®¤éšè—æ§åˆ¶é¢æ¿ï¼Œæ˜¾ç¤ºåˆ‡æ¢æŒ‰é’®
                document.getElementById('axis-controls').classList.add('hidden');
                document.getElementById('controls').classList.add('hidden');
            } else {
                // æ¡Œé¢ç«¯ï¼šé»˜è®¤æ˜¾ç¤ºè½´æ§åˆ¶é¢æ¿
                document.getElementById('axis-controls').classList.remove('hidden');
                const btn = document.getElementById('axisControlBtn');
                btn.classList.add('active');
                btn.textContent = 'ğŸ¯ éšè—æ§åˆ¶';
            }
        }

        // ç§»åŠ¨ç«¯æ§åˆ¶é¢æ¿åˆ‡æ¢
        let mobileControlsVisible = false;
        function toggleMobileControls() {
            const axisControls = document.getElementById('axis-controls');
            const controls = document.getElementById('controls');
            const toggleBtn = document.getElementById('mobileToggle');
            
            mobileControlsVisible = !mobileControlsVisible;
            
            if (mobileControlsVisible) {
                axisControls.classList.remove('hidden');
                axisControls.classList.add('show');
                controls.classList.remove('hidden');
                controls.classList.add('show');
                toggleBtn.textContent = 'âœ–ï¸';
                toggleBtn.style.background = 'rgba(255, 0, 0, 0.7)';
            } else {
                axisControls.classList.remove('show');
                controls.classList.remove('show');
                toggleBtn.textContent = 'âš™ï¸';
                toggleBtn.style.background = 'rgba(0, 0, 0, 0.7)';
                
                // å»¶è¿Ÿéšè—ï¼Œç­‰å¾…åŠ¨ç”»å®Œæˆ
                setTimeout(() => {
                    if (!mobileControlsVisible) {
                        axisControls.classList.add('hidden');
                        controls.classList.add('hidden');
                    }
                }, 300);
            }
        }

        // ä¸€é”®éšè—æ‰€æœ‰æ“ä½œç•Œé¢
        let allHidden = false;
        function toggleHideAll() {
            const axisControls = document.getElementById('axis-controls');
            const controls = document.getElementById('controls');
            const instructions = document.getElementById('instructions');
            const zoomInfo = document.getElementById('zoom-info');
            const mobileToggle = document.getElementById('mobileToggle');
            const hideAllBtn = document.getElementById('hideAllToggle');
            
            allHidden = !allHidden;
            
            if (allHidden) {
                // éšè—æ‰€æœ‰æ“ä½œç•Œé¢
                axisControls.classList.add('hidden');
                controls.classList.add('hidden');
                instructions.classList.add('hidden');
                zoomInfo.classList.remove('show');
                mobileToggle.style.display = 'none';
                
                // æ›´æ–°æŒ‰é’®çŠ¶æ€
                hideAllBtn.classList.add('hidden-mode');
                hideAllBtn.textContent = 'ğŸ”™';
                hideAllBtn.title = 'æ˜¾ç¤ºæ‰€æœ‰æ“ä½œç•Œé¢';
                
                // é‡ç½®ç§»åŠ¨ç«¯æ§åˆ¶çŠ¶æ€
                mobileControlsVisible = false;
                
                console.log('å·²éšè—æ‰€æœ‰æ“ä½œç•Œé¢ï¼Œåªä¿ç•™æ ‡é¢˜');
            } else {
                // æ˜¾ç¤ºæ‰€æœ‰æ“ä½œç•Œé¢
                const isMobile = window.innerWidth <= 768;
                
                if (isMobile) {
                    // ç§»åŠ¨ç«¯ï¼šæ˜¾ç¤ºåˆ‡æ¢æŒ‰é’®ï¼Œä½†æ§åˆ¶é¢æ¿ä¿æŒéšè—çŠ¶æ€
                    mobileToggle.style.display = 'block';
                } else {
                    // æ¡Œé¢ç«¯ï¼šç›´æ¥æ˜¾ç¤ºæ§åˆ¶é¢æ¿
                    axisControls.classList.remove('hidden');
                    controls.classList.remove('hidden');
                }
                
                instructions.classList.remove('hidden');
                mobileToggle.style.display = isMobile ? 'block' : 'none';
                
                // æ›´æ–°æŒ‰é’®çŠ¶æ€
                hideAllBtn.classList.remove('hidden-mode');
                hideAllBtn.textContent = 'âœ–ï¸';
                hideAllBtn.title = 'éšè—æ‰€æœ‰æ“ä½œç•Œé¢';
                
                console.log('å·²æ˜¾ç¤ºæ‰€æœ‰æ“ä½œç•Œé¢');
            }
        }

        // åˆ‡æ¢è½´æ§åˆ¶é¢æ¿æ˜¾ç¤º
        function toggleAxisControls() {
            const axisControls = document.getElementById('axis-controls');
            const btn = document.getElementById('axisControlBtn');
            
            isAxisControlsVisible = !isAxisControlsVisible;
            
            if (isAxisControlsVisible) {
                axisControls.classList.remove('hidden');
                btn.classList.add('active');
                btn.textContent = 'ğŸ¯ éšè—æ§åˆ¶';
            } else {
                axisControls.classList.add('hidden');
                btn.classList.remove('active');
                btn.textContent = 'ğŸ¯ æ¨¡å‹æ§åˆ¶';
            }
        }

        // ç§»åŠ¨æ¨¡å‹ä½ç½® - æ–°å¢åŠŸèƒ½
        function moveModel(axis, direction) {
            if (!model) return;
            
            // è®¡ç®—ç§»åŠ¨è·ç¦»ï¼ˆåŸºäºæ¨¡å‹å¤§å°å’Œé€Ÿåº¦ï¼‰
            const maxDim = Math.max(modelSize.x, modelSize.y, modelSize.z);
            const moveDistance = (maxDim * 0.1) * rotationSpeed * direction;
            
            // æš‚æ—¶ç¦ç”¨è½¨é“æ§åˆ¶å™¨ï¼Œé¿å…å†²çª
            controls.enabled = false;
            
            // æ ¹æ®è½´å‘è¿›è¡Œç§»åŠ¨
            switch(axis) {
                case 'x':
                    model.position.x += moveDistance;
                    break;
                case 'y':
                    model.position.y += moveDistance;
                    break;
                case 'z':
                    model.position.z += moveDistance;
                    break;
            }
            
            // çŸ­æš‚å»¶è¿Ÿåé‡æ–°å¯ç”¨æ§åˆ¶å™¨
            setTimeout(() => {
                controls.enabled = true;
            }, 100);
            
            // æ·»åŠ è§†è§‰åé¦ˆ
            showMovementFeedback(axis, direction);
        }

        // æ˜¾ç¤ºç§»åŠ¨åé¦ˆ
        function showMovementFeedback(axis, direction) {
            const feedback = document.createElement('div');
            feedback.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(255, 165, 0, 0.9);
                color: white;
                padding: 10px 20px;
                border-radius: 20px;
                font-size: 14px;
                z-index: 1000;
                pointer-events: none;
                backdrop-filter: blur(10px);
                border: 2px solid rgba(255, 165, 0, 0.5);
            `;
            
            const axisNames = {
                'x': 'å·¦å³',
                'y': 'ä¸Šä¸‹', 
                'z': 'å‰å'
            };
            
            const directionText = {
                'x': direction > 0 ? 'å³ç§»' : 'å·¦ç§»',
                'y': direction > 0 ? 'ä¸Šç§»' : 'ä¸‹ç§»',
                'z': direction > 0 ? 'å‰ç§»' : 'åç§»'
            };
            
            feedback.textContent = `ğŸ“ ${axisNames[axis]}${directionText[axis]}`;
            
            document.body.appendChild(feedback);
            
            // 1ç§’åç§»é™¤åé¦ˆ
            setTimeout(() => {
                if (document.body.contains(feedback)) {
                    document.body.removeChild(feedback);
                }
            }, 1000);
        }

        // é‡ç½®æ¨¡å‹ä½ç½®
        function resetModelPosition() {
            if (!model) return;
            
            model.position.set(0, 0, 0);
            showMovementFeedback('reset', 0);
        }

        // æ—‹è½¬æ¨¡å‹ - æ ¸å¿ƒåŠŸèƒ½
        function rotateModel(axis, direction) {
            if (!model) return;
            
            // è®¡ç®—æ—‹è½¬è§’åº¦ï¼ˆåŸºäºé€Ÿåº¦ï¼‰
            const angle = (Math.PI / 180) * 15 * rotationSpeed * direction;
            
            // æš‚æ—¶ç¦ç”¨è½¨é“æ§åˆ¶å™¨ï¼Œé¿å…å†²çª
            controls.enabled = false;
            
            // æ ¹æ®è½´å‘è¿›è¡Œæ—‹è½¬
            switch(axis) {
                case 'x':
                    model.rotateX(angle);
                    break;
                case 'y':
                    model.rotateY(angle);
                    break;
                case 'z':
                    model.rotateZ(angle);
                    break;
            }
            
            // çŸ­æš‚å»¶è¿Ÿåé‡æ–°å¯ç”¨æ§åˆ¶å™¨
            setTimeout(() => {
                controls.enabled = true;
            }, 100);
            
            // æ·»åŠ è§†è§‰åé¦ˆ
            showRotationFeedback(axis, direction);
        }

        // æ˜¾ç¤ºæ—‹è½¬åé¦ˆ
        function showRotationFeedback(axis, direction) {
            const feedback = document.createElement('div');
            feedback.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0, 0, 0, 0.8);
                color: white;
                padding: 10px 20px;
                border-radius: 20px;
                font-size: 14px;
                z-index: 1000;
                pointer-events: none;
                backdrop-filter: blur(10px);
            `;
            
            const axisColors = {
                'x': 'ğŸ”´',
                'y': 'ğŸŸ¢', 
                'z': 'ğŸ”µ'
            };
            
            const directionText = direction > 0 ? 'é¡ºæ—¶é’ˆ' : 'é€†æ—¶é’ˆ';
            feedback.textContent = `${axisColors[axis]} ${axis.toUpperCase()}è½´ ${directionText}æ—‹è½¬`;
            
            document.body.appendChild(feedback);
            
            // 1ç§’åç§»é™¤åé¦ˆ
            setTimeout(() => {
                document.body.removeChild(feedback);
            }, 1000);
        }

        // æ›´æ–°æ—‹è½¬é€Ÿåº¦
        function updateRotationSpeed() {
            rotationSpeed = parseFloat(document.getElementById('rotationSpeed').value);
            document.getElementById('speedValue').textContent = rotationSpeed + 'x';
        }

        // é‡ç½®æ¨¡å‹æ—‹è½¬å’Œä½ç½®
        function resetModelRotation() {
            if (!model) return;
            
            // é‡ç½®åˆ°åˆå§‹çŠ¶æ€ï¼šXè½´-90åº¦ï¼ŒZè½´é¡ºæ—¶é’ˆæ—‹è½¬1æ¬¡
            model.rotation.set(-Math.PI / 2, 0, (Math.PI / 180) * 15 * rotationSpeed * 1);
            
            // é‡ç½®ä½ç½®ï¼šå‘å·¦ç§»åŠ¨4æ¬¡ï¼Œå‘ä¸‹ç§»åŠ¨4æ¬¡
            const maxDim = Math.max(modelSize.x, modelSize.y, modelSize.z);
            const moveDistance = maxDim * 0.1 * rotationSpeed;
            model.position.set(-moveDistance * 4, -moveDistance * 4, 0);
            
            const feedback = document.createElement('div');
            feedback.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(76, 175, 80, 0.9);
                color: white;
                padding: 10px 20px;
                border-radius: 20px;
                font-size: 14px;
                z-index: 1000;
                pointer-events: none;
                backdrop-filter: blur(10px);
            `;
            feedback.textContent = 'ğŸ”„ å·²é‡ç½®åˆ°åˆå§‹çŠ¶æ€';
            
            document.body.appendChild(feedback);
            setTimeout(() => {
                if (document.body.contains(feedback)) {
                    document.body.removeChild(feedback);
                }
            }, 1500);
        }

        // æ¸²æŸ“å¾ªç¯
        function animate() {
            requestAnimationFrame(animate);
            
            // æ›´æ–°æ§åˆ¶å™¨
            controls.update();
            
            // æ¸²æŸ“åœºæ™¯
            renderer.render(scene, camera);
        }

        // çª—å£å¤§å°å˜åŒ–å¤„ç†
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            // æ£€æµ‹è®¾å¤‡ç±»å‹å˜åŒ–ï¼Œé‡æ–°è°ƒæ•´æ§åˆ¶é¢æ¿
            const isMobile = window.innerWidth <= 768;
            const axisControls = document.getElementById('axis-controls');
            const controls = document.getElementById('controls');
            
            if (isMobile) {
                // åˆ‡æ¢åˆ°ç§»åŠ¨ç«¯æ¨¡å¼
                if (!axisControls.classList.contains('hidden')) {
                    mobileControlsVisible = false;
                    toggleMobileControls();
                }
            } else {
                // åˆ‡æ¢åˆ°æ¡Œé¢æ¨¡å¼
                axisControls.classList.remove('hidden', 'show');
                controls.classList.remove('hidden', 'show');
                axisControls.style.transform = '';
                controls.style.transform = '';
            }
        }

        // é‡ç½®ç›¸æœºä½ç½®
        function resetCamera() {
            if (model) {
                fitToScreen();
            }
        }

        // åˆ‡æ¢çº¿æ¡†æ¨¡å¼
        function toggleWireframe() {
            if (model) {
                isWireframe = !isWireframe;
                model.material.wireframe = isWireframe;
                
                const btn = document.getElementById('wireframeBtn');
                btn.classList.toggle('active', isWireframe);
                btn.textContent = isWireframe ? 'ğŸ“ å®ä½“æ¨¡å¼' : 'ğŸ“ çº¿æ¡†æ¨¡å¼';
            }
        }

        // æ›´æ–°å…‰ç…§å¼ºåº¦
        function updateLighting() {
            const intensity = parseFloat(document.getElementById('lightIntensity').value);
            document.getElementById('lightValue').textContent = intensity.toFixed(1);
            
            if (directionalLight) {
                directionalLight.intensity = intensity;
            }
        }

        // æ”¹å˜æ¨¡å‹é¢œè‰²
        function changeColor(color) {
            if (model) {
                model.material.color.setHex(color.replace('#', '0x'));
            }
        }

        // æ”¹å˜èƒŒæ™¯
        function changeBackground(type) {
            const body = document.body;
            
            // ç§»é™¤æ‰€æœ‰æŒ‰é’®çš„ active ç±»
            document.querySelectorAll('[id^="bg"]').forEach(btn => btn.classList.remove('active'));
            
            switch(type) {
                case 'gradient':
                    body.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
                    document.getElementById('bgGradient').classList.add('active');
                    break;
                case 'dark':
                    body.style.background = '#2c3e50';
                    document.getElementById('bgDark').classList.add('active');
                    break;
                case 'light':
                    body.style.background = 'linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%)';
                    document.getElementById('bgLight').classList.add('active');
                    break;
            }
        }

        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        window.addEventListener('DOMContentLoaded', init);

        // æ·»åŠ é”®ç›˜å¿«æ·é”®
        document.addEventListener('keydown', function(event) {
            if (event.target.tagName === 'INPUT') return; // å¿½ç•¥è¾“å…¥æ¡†ä¸­çš„æŒ‰é”®
            
            switch(event.code) {
                case 'KeyR':
                    if (event.shiftKey) {
                        resetModelRotation();
                    } else {
                        resetCamera();
                    }
                    break;
                case 'KeyW':
                    toggleWireframe();
                    break;
                case 'KeyF':
                    fitToScreen();
                    break;
                case 'KeyT':
                    toggleAxisControls();
                    break;
                case 'KeyH':
                    toggleHideAll();
                    break;
                case 'Equal':
                case 'NumpadAdd':
                    zoomIn();
                    break;
                case 'Minus':
                case 'NumpadSubtract':
                    zoomOut();
                    break;
                // Xè½´æ—‹è½¬ (Q/Eé”®)
                case 'KeyQ':
                    rotateModel('x', -1);
                    break;
                case 'KeyE':
                    rotateModel('x', 1);
                    break;
                // Yè½´æ—‹è½¬ (A/Dé”®)
                case 'KeyA':
                    rotateModel('y', -1);
                    break;
                case 'KeyD':
                    rotateModel('y', 1);
                    break;
                // Zè½´æ—‹è½¬ (Z/Cé”®)
                case 'KeyZ':
                    rotateModel('z', -1);
                    break;
                case 'KeyC':
                    rotateModel('z', 1);
                    break;
                // ä½ç½®ç§»åŠ¨ (æ–¹å‘é”®)
                case 'ArrowLeft':
                    event.preventDefault();
                    moveModel('x', -1);
                    break;
                case 'ArrowRight':
                    event.preventDefault();
                    moveModel('x', 1);
                    break;
                case 'ArrowUp':
                    event.preventDefault();
                    if (event.shiftKey) {
                        moveModel('z', 1); // Shift+ä¸Šç®­å¤´ï¼šå‰ç§»
                    } else {
                        moveModel('y', 1); // ä¸Šç®­å¤´ï¼šä¸Šç§»
                    }
                    break;
                case 'ArrowDown':
                    event.preventDefault();
                    if (event.shiftKey) {
                        moveModel('z', -1); // Shift+ä¸‹ç®­å¤´ï¼šåç§»
                    } else {
                        moveModel('y', -1); // ä¸‹ç®­å¤´ï¼šä¸‹ç§»
                    }
                    break;
                // é¢œè‰²å¿«æ·é”®
                case 'Digit1':
                    changeColor('#ff8c00'); // é‡‘è‰²
                    break;
                case 'Digit2':
                    changeColor('#4ecdc4');
                    break;
                case 'Digit3':
                    changeColor('#45b7d1');
                    break;
                case 'Digit4':
                    changeColor('#96ceb4');
                    break;
                case 'Digit5':
                    changeColor('#FF6103'); // æ©™è‰²
                    break;
            }
        });

        // é˜²æ­¢é¡µé¢æ»šåŠ¨å½±å“3Dæ§åˆ¶
        document.addEventListener('wheel', function(e) {
            if (e.target.closest('#canvas-container')) {
                e.preventDefault();
            }
        }, { passive: false });
    </script>
</body>
</html>